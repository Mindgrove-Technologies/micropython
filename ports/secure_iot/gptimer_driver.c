/**
 * Project                           : Secure IoT SoC
 * Name of the file                  : gptimer_driver.c
 * Brief Description of file         : Driver to Standard gp_timer driver
 * Name of Author                    : Suneeth D, Shri Mahaalakshmi S J
 * Email ID                          : suneethdamodharan@gmail.com, mahaalakshmi@mindgrovetech.in
 * 
 * @file gptimer.h
 * @author Suneeth D (suneethdamodharan@gmail.com)
 * @author Shri Mahaalakshmi S J (mahaalakshmi@mindgrovetech.in)
 * @brief This is a Baremetal GP_TIMER Driver's header file for Mindgrove Silicon's General Purpose Timer module.
 * @version 0.2
 * @date 2024-09-20
 * 
 * @copyright Copyright (c) Mindgrove Technologies Pvt. Ltd 2024. All rights reserved.
 * 
 */

#include "gptimer.h"

#define DEBUG 0
int delay_done; /*!< Global variable telling the desirable delay has been generated by the gptimer0*/
// Overflow tracking variables
volatile uint32_t overflow_count = 0;
volatile uint32_t last_timer_value = 0;

#define GPT_MAX_COUNT 4
#define CHECK_UPDATE_EN 0x20000
#define CONTROL_REG(gpt_num) gpt_instance[gpt_num] -> CTRL 
#define CLOCK_CNTRL(gpt_num) gpt_instance[gpt_num] -> CLOCK_CTRL
#define COUNTER_VAL(gpt_num) gpt_instance[gpt_num] -> COUNT
#define REPEATD_COUNT(gpt_num) gpt_instance[gpt_num] -> RPTD_COUNT
#define DUTY_CYCL(gpt_num) gpt_instance[gpt_num] -> DUTY_CYCLE
#define PERIOD_REG(gpt_num) gpt_instance[gpt_num]-> PERIOD
#define CAPTR_VAL(gpt_num) gpt_instance[gpt_num] -> CAPTURE_INP

/* Bit Specifications of each GP_TIMER's register*/
/* Control Register */
#define GPT_EN              (1<<0)
#define GPT_MODE(x)         (x<<2)
#define GPT_OUTPUT_EN       (1<<4)
#define COUNT_RESET         (1<<5)
#define CONTIN_CNT_EN       (1<<6)
#define PWM_FALL_INTR_EN    (1<<7) 
#define PWM_RISE_INTR_EN    (1<<8)
#define CNTR_OFLOW_INTR_EN  (1<<9)
#define CNTR_UFLOW_INTR_EN  (1<<10)
#define PWM_RISE_INTR       (1<<11)
#define PWM_FALL_INTR       (1<<12)
#define CNTR_OFLOW_INTR     (1<<13)
#define CNTR_UFLOW_INTR     (1<<14)
#define CAPTURE_IP(x)   (x<<15) 

/* Clock Control Reg*/
#define clk_src (0<<0)
#define clk_prescalar(x)    (x<<1)
#define clk_update_en(x)    (x<<17)

/* Duty Cycle Reg*/
#define DUTY_CYC_VAL(x)     (x<<0)

/* Period Reg*/
#define PRD_VAL(x)          (x<<0)

GPTIMER_Type *gpt_instance[GPT_MAX_COUNT];

uint32_t GPT_Set_Period(GPTIMER_Config_t *gptimer)
{
    // GPT_Update_Enable(gptimer);
    PERIOD_REG(gptimer->gpt_num) = (PERIOD_REG(gptimer->gpt_num) & 0x00000000) | gptimer->period;
    log_debug("Period register : %x\n", PERIOD_REG(gptimer->gpt_num));
    return SUCCESS;
}

uint32_t GPT_Set_Dutycycle(GPTIMER_Config_t *gptimer)
{
    // GPT_Update_Enable(gptimer);
    printf("\n Inside duty cycle ");
    int dut_cyc;
    dut_cyc = ((int)(gptimer->dutycycle * gptimer->period))/100;
    DUTY_CYCL(gptimer->gpt_num) = (DUTY_CYCL(gptimer->gpt_num) & 0x00000000) | dut_cyc;
    log_debug("Dutycycle value: %x\n", DUTY_CYCL(gptimer->gpt_num));
    return SUCCESS;
}

uint32_t GPT_Set_Prescalar(GPTIMER_Config_t *gptimer)
{
    if(gptimer->prescalar != 0)
    {
        CLOCK_CNTRL(gptimer->gpt_num) |= (clk_prescalar(gptimer->prescalar) & 0xFFFFFFFE);
        log_debug("Clock register : %x\n", CLOCK_CNTRL(gptimer->gpt_num));
    }

    else
    {        
        log_error("Invalid Prescalar Value! Expected Prescalar Value: > 0\n");    
    }
    return SUCCESS;
}

uint32_t GPT_Init(GPTIMER_Config_t *gptimer)
{
    if(DEBUG)
        printf("1******************\n");
    switch (gptimer->gpt_num)
    {
    case GPTIMER_0:
        gpt_instance[gptimer->gpt_num] = GPTIMER0;
        break;
    case GPTIMER_1:
        gpt_instance[gptimer->gpt_num] = GPTIMER1;
        break;
    case GPTIMER_2:
        gpt_instance[gptimer->gpt_num] = GPTIMER2;
        break;
    case GPTIMER_3:
        gpt_instance[gptimer->gpt_num] = GPTIMER3;
        break;
    default:
        log_error("Invalid access attempt! Try access number <4\n");
        return EPERM;
    }
    if(DEBUG)
        printf("2******************\n");
 
    GPT_Update_Enable(gptimer);
    GPT_Set_Period(gptimer);
    GPT_Set_Prescalar(gptimer);
    
    if(gptimer->cnt_en == GPT_CONTIN_COUNT_EN)
    {        
        CONTROL_REG(gptimer->gpt_num) |= CONTIN_CNT_EN;            
    }

    if(gptimer->output_en == GPT_OUT_EN)
    {
        CONTROL_REG(gptimer->gpt_num) |= GPT_OUTPUT_EN;
    }

    if(gptimer->mode == GPT_PWM_MODE)
    {
        CONTROL_REG(gptimer->gpt_num) |= PWM_FALL_INTR_EN | PWM_RISE_INTR_EN;
        if ((gptimer->dutycycle <= 100) && (gptimer->dutycycle >= 0))
        {
            GPT_Set_Dutycycle(gptimer);        
        }

        else
        {
            log_error("Invalid DutyCycle value! Expected value: <= 100\n");
        }
    }

    else if(gptimer->mode == GPT_UP_COUNT)
    {
        if(gptimer->interrupt_en == GPT_INTR_EN)
            CONTROL_REG(gptimer->gpt_num) |= CNTR_OFLOW_INTR_EN;
        else
            CONTROL_REG(gptimer->gpt_num) &= ~CNTR_OFLOW_INTR_EN;
    }

    else if(gptimer->mode == GPT_DOWM_COUNT /*&& interrupt_en == 1*/)
    {
        if(gptimer->interrupt_en == GPT_INTR_EN)
            CONTROL_REG(gptimer->gpt_num) |= CNTR_UFLOW_INTR_EN;
        else
            CONTROL_REG(gptimer->gpt_num) &= ~CNTR_UFLOW_INTR_EN;
    }

    else if(gptimer->mode == GPT_UPDOWN_COUNT /*&& interrupt_en == 1*/)
    {
        if(gptimer->interrupt_en == GPT_INTR_EN)
            CONTROL_REG(gptimer->gpt_num) |= CNTR_OFLOW_INTR_EN | CNTR_UFLOW_INTR_EN;
        else
            CONTROL_REG(gptimer->gpt_num) &= ~(CNTR_OFLOW_INTR_EN | CNTR_UFLOW_INTR_EN);
    }

    else 
    {
        log_error("Invalid Mode value! Expected value < 4\n");
    }

    CONTROL_REG(gptimer->gpt_num) |= GPT_EN | GPT_MODE(gptimer->mode) | CAPTURE_IP(gptimer->capture_val) | COUNT_RESET;  //Starting the Counter/PWM wrt its mode of operation
    if(DEBUG)
        printf("\n exiting init");
    return SUCCESS;
}

uint32_t GPT_Update_Enable(GPTIMER_Config_t *gptimer)
{
        printf("\n Update enable ");
    if(CLOCK_CNTRL(gptimer->gpt_num) & CHECK_UPDATE_EN)
    {
        CLOCK_CNTRL(gptimer->gpt_num) = (0xFFFDFFFF & CLOCK_CNTRL(gptimer->gpt_num));
        log_debug("Clock register : %x\n", CLOCK_CNTRL(gptimer->gpt_num));
        log_debug("Clock register : %x\n", (0xFFFDFFFF & CLOCK_CNTRL(gptimer->gpt_num)));
    }
    return SUCCESS;
}

uint32_t GPT_Read_Counter_Val(GPTIMER_Config_t *gptimer)
{
    log_debug("Counter value : %x\n", COUNTER_VAL(gptimer->gpt_num));
    return COUNTER_VAL(gptimer->gpt_num);
}

uint32_t GPT_Read_ReptdCount(GPTIMER_Config_t *gptimer)
{
    log_debug("Repeated count value : %x\n", REPEATD_COUNT(gptimer->gpt_num));
    return REPEATD_COUNT(gptimer->gpt_num);
}

uint32_t GPT_Read_Captured_Val(GPTIMER_Config_t *gptimer)
{
    log_debug("Captured value : %x\n", CAPTR_VAL(gptimer->gpt_num));
    return CAPTR_VAL(gptimer->gpt_num);
}


uint32_t GPT_Reset(GPTIMER_Config_t *gptimer)
{
    CONTROL_REG(gptimer->gpt_num) |= 0x00000020;
    log_debug("Control register: %x\n", CONTROL_REG(gptimer->gpt_num));

    return SUCCESS;
}

 
int readRiseintrpt(GPTIMER_Config_t *gptimer){

    while(!(CONTROL_REG(gptimer->gpt_num) & (1<<11)));
    return 1;
}

int readFallintrpt(GPTIMER_Config_t *gptimer){

    while(!(CONTROL_REG(gptimer->gpt_num) & (1<<12)));
    return 1;
}


int readDutyCycle(GPTIMER_Config_t *gptimer){

    return DUTY_CYCL(gptimer->gpt_num);
}


void handle_gptimer_interrupt_for_delay() {
  delay_done = 1;
   if(DEBUG){
    printf("Overflow:%x\n",CNTR_OFLOW_INTR);
    printf("Underflow:%x\n",CNTR_UFLOW_INTR);
   }
  GPTIMER_Config_t gptimer;
  gptimer.gpt_num=GPTIMER_0;
  gptimer.mode=1;
  gptimer.interrupt_en=0;
  gptimer.period=2;
  gptimer.prescalar=2;
  gptimer.dutycycle=0;
  gptimer.cnt_en=1;
  gptimer.capture_val=0;
  gptimer.output_en=0;
  if(DEBUG)
    printf("calling init 2\n");
  GPT_Init(&gptimer);
  if(DEBUG){
      printf("\n period:%d",gptimer.period);
      printf("Overflow:%x\n",CNTR_OFLOW_INTR);
      printf("Underflow:%x\n",CNTR_UFLOW_INTR);
  }
}

uint32_t GPT_Delay_Milliseconds(GPTIMER_Config_t *gptimer, uint32_t delay) 
{
    delay_done = 0;
    PLIC_Init();
    PLIC_Config_t plic_config;
	plic_config.interrupt_id= GPTIMER0_IRQn;
	plic_config.fptr = handle_gptimer_interrupt_for_delay;
	plic_config.priority_value=PLIC_PRIORITY_3;
	IRQ_Connect(&plic_config);
    uint32_t prescalar = CLOCK_FREQUENCY_BASE/1000000;
    uint32_t period = delay * 1000;
    gptimer->period = period;
    gptimer->interrupt_en = 1;
    gptimer->prescalar = prescalar;
    GPT_Init(gptimer);
    while(!delay_done);
    // INTERRUPT_Disable(GPTIMER_IRQn);
    GPT_Reset(gptimer);
    return SUCCESS;
}


uint32_t GPT_Delay_Millisecs_H(uint32_t delay) 
{
    delay_done = 0;
    PLIC_Init();
    if(DEBUG)
        printf("\n Hello1");
    PLIC_Config_t plic_config;
	plic_config.interrupt_id= GPTIMER0_IRQn;
	plic_config.fptr = handle_gptimer_interrupt_for_delay;
    if(DEBUG)
        printf("\n Hello2");
	plic_config.priority_value=PLIC_PRIORITY_3;
	IRQ_Connect(&plic_config);
    if(DEBUG)
        printf("\n Hello3");
   GPTIMER_Config_t gptimer;
    uint32_t prescalar = CLOCK_FREQUENCY_BASE/1000000;
    uint32_t period = delay * 1000;
    gptimer.gpt_num=GPTIMER_0;
    gptimer.mode=1;
    gptimer.period=period;
    gptimer.prescalar=prescalar; 
    gptimer.interrupt_en=1;
    gptimer.capture_val=0;
    gptimer.output_en=0;
    gptimer.cnt_en=0;
    gptimer.dutycycle=0;
    if(DEBUG)
        printf("Hello4\n");
    GPT_Init(&gptimer);
    if(DEBUG)
        printf("Hello 5\n");
    while(!delay_done);
    if(DEBUG)
        printf("\n period:%d",gptimer.period);
    GPT_Reset(&gptimer);
    if(DEBUG)
     {
        printf("Overflow:%d\n",CNTR_OFLOW_INTR);
        printf("counter:%x\n",COUNTER_VAL(gptimer.gpt_num));
        printf("mode:%x\n",gptimer.mode);
     }
         return SUCCESS;

}

uint32_t GPT_Delay_Microseconds(GPTIMER_Config_t *gptimer, uint32_t delay) 
{
    delay_done = 0;
    PLIC_Init();
    PLIC_Config_t plic_config;
	plic_config.interrupt_id= GPTIMER0_IRQn;
	plic_config.fptr = handle_gptimer_interrupt_for_delay;
	plic_config.priority_value=PLIC_PRIORITY_3;
	IRQ_Connect(&plic_config);
    uint32_t prescalar = CLOCK_FREQUENCY_BASE/1000000;
    uint32_t period = delay * 1;
    gptimer->period = period;
    gptimer->interrupt_en = 1;
    gptimer->prescalar = prescalar;
    GPT_Init(gptimer);
    while(!delay_done);
    GPT_Reset(gptimer);
    return SUCCESS;
}

uint32_t GPT_Delay_Microsecs_H(uint32_t delay) 
{
   
    delay_done = 0;
    PLIC_Init();
    // printf("\n Hello1");
    PLIC_Config_t plic_config;
	plic_config.interrupt_id= GPTIMER0_IRQn;
	plic_config.fptr = handle_gptimer_interrupt_for_delay;
    // printf("\n Hello2");
	plic_config.priority_value=PLIC_PRIORITY_3;
	IRQ_Connect(&plic_config);
    // printf("\n Hello3");
    GPTIMER_Config_t gptimer;
    uint32_t prescalar = CLOCK_FREQUENCY_BASE/1000000;
    uint32_t period = delay * 1;
    gptimer.gpt_num=GPTIMER_0;
    gptimer.mode=1;
    gptimer.period=period;
    gptimer.prescalar=prescalar;
    gptimer.interrupt_en=1;
    gptimer.capture_val=0;
    gptimer.output_en=0;
    gptimer.cnt_en=0;
    gptimer.dutycycle=0;
    // printf("Hello4\n");
    GPT_Init(&gptimer);
    // printf("Hello 5\n");
    while(!delay_done);
    GPT_Reset(&gptimer);
    return SUCCESS;
   
}



// // Manually track overflow in polling mode
// void check_timer_overflow(GPTIMER_Config_t *gptimer) {
//     uint32_t current_timer_value = COUNTER_VAL(gptimer->gpt_num);

//     if (current_timer_value < last_timer_value) {  // Overflow detected
//         overflow_count++;
//     }

//     last_timer_value = current_timer_value;
// }

// // **millis() using GPTimer**
// uint32_t millis(GPTIMER_Config_t *gptimer) {
//     check_timer_overflow(gptimer);  // Check for overflow
//     uint32_t full_time = ((uint64_t)overflow_count << 32) | COUNTER_VAL(gptimer->gpt_num);
//     return full_time / 1000;  // Convert to milliseconds (assuming 1 MHz clock)
// }

// // **Example Usage**
// int main() {
//      GPTIMER_Config_t gptimer;
//     uint32_t prescalar = CLOCK_FREQUENCY_BASE/1000000;
//     uint32_t period =  1;
//     gptimer.gpt_num=GPTIMER_0;
//     gptimer.mode=1;
//     gptimer.period=period;
//     gptimer.prescalar=prescalar;
//     gptimer.interrupt_en=1;
//     gptimer.capture_val=0;
//     gptimer.output_en=0;
//     gptimer.cnt_en=0;
//     gptimer.dutycycle=0;
//     // printf("Hello4\n");
//     GPT_Init(&gptimer);

//     uint64_t start_time = millis(&gptimer);

//     while (1) {
//         if (millis(&gptimer) - start_time > 5000) {  // 5 seconds passed
//             start_time = millis(&gptimer);  // Reset start time
//         }
//     }

//     return 0;
// }


uint32_t GPT_Intr_disable(GPTIMER_Config_t *gptimer){
        printf("\n intr disable");
        CONTROL_REG(gptimer->gpt_num) &= ~( PWM_FALL_INTR_EN | PWM_RISE_INTR_EN);

}